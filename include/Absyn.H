#ifndef ABSYN_HEADER
#define ABSYN_HEADER

#include<string>
#include<vector>
#include "include/JType.H"

//C++ Abstract Syntax Interface generated by the BNF Converter.

/********************   TypeDef Section    ********************/

typedef int Integer;
typedef char Char;
typedef double Double;
typedef std::string String;
typedef std::string Ident;


typedef std::string Boolean;


/********************   Forward Declarations    ********************/

class Prog;
class FunDef;
class Type;
class Arg;
class Instr;
class Decl;
class Expr;
class Literal;
class Program;
class Function;
class IntType;
class DoubleType;
class VoidType;
class BoolType;
class FunctionArg;
class CompundInstr;
class InnerFunction;
class ReturnExpr;
class ReturnExprInstr;
class DeclInstr;
class ConditionalIf;
class ConditionalIfElse;
class ExpresionInstr;
class ForLoop;
class WhileLoop;
class OnlyDeclarator;
class InitDeclarator;
class Assigment;
class PostDecrement;
class PostIncrement;
class Cast;
class LogExprOr;
class LogExprAnd;
class LogExprEq;
class LogExprNeq;
class RelExprL;
class RelExprG;
class RelExprLe;
class RelExprGe;
class AddExpr;
class DecExpr;
class MulExpr;
class DivExpr;
class ModExpr;
class NegExpr;
class PlusExpr;
class MinusExpr;
class FunctionCall;
class ArrayAccess;
class IdentExpr;
class LiteralExpr;
class LiteralInteger;
class LiteralDouble;
class LiteralString;
class LiteralBoolean;
class ListFunDef;
class ListArg;
class ListInstr;
class ListDecl;
class ListExpr;


/********************   Visitor Interfaces    ********************/
class Visitor {
public:
    virtual ~Visitor() {}
    virtual void visitProg(Prog *p) = 0;
    virtual void visitFunDef(FunDef *p) = 0;
    virtual void visitType(Type *p) = 0;
    virtual void visitArg(Arg *p) = 0;
    virtual void visitInstr(Instr *p) = 0;
    virtual void visitDecl(Decl *p) = 0;
    virtual void visitExpr(Expr *p) = 0;
    virtual void visitLiteral(Literal *p) = 0;
    virtual void visitProgram(Program *p) = 0;
    virtual void visitFunction(Function *p) = 0;
    virtual void visitIntType(IntType *p) = 0;
    virtual void visitDoubleType(DoubleType *p) = 0;
    virtual void visitVoidType(VoidType *p) = 0;
    virtual void visitBoolType(BoolType *p) = 0;
    virtual void visitFunctionArg(FunctionArg *p) = 0;
    virtual void visitCompundInstr(CompundInstr *p) = 0;
    virtual void visitInnerFunction(InnerFunction *p) = 0;
    virtual void visitReturnExpr(ReturnExpr *p) = 0;
    virtual void visitReturnExprInstr(ReturnExprInstr *p) = 0;
    virtual void visitDeclInstr(DeclInstr *p) = 0;
    virtual void visitConditionalIf(ConditionalIf *p) = 0;
    virtual void visitConditionalIfElse(ConditionalIfElse *p) = 0;
    virtual void visitExpresionInstr(ExpresionInstr *p) = 0;
    virtual void visitForLoop(ForLoop *p) = 0;
    virtual void visitWhileLoop(WhileLoop *p) = 0;
    virtual void visitOnlyDeclarator(OnlyDeclarator *p) = 0;
    virtual void visitInitDeclarator(InitDeclarator *p) = 0;
    virtual void visitAssigment(Assigment *p) = 0;
    virtual void visitPostDecrement(PostDecrement *p) = 0;
    virtual void visitPostIncrement(PostIncrement *p) = 0;
    virtual void visitCast(Cast *p) = 0;
    virtual void visitLogExprOr(LogExprOr *p) = 0;
    virtual void visitLogExprAnd(LogExprAnd *p) = 0;
    virtual void visitLogExprEq(LogExprEq *p) = 0;
    virtual void visitLogExprNeq(LogExprNeq *p) = 0;
    virtual void visitRelExprL(RelExprL *p) = 0;
    virtual void visitRelExprG(RelExprG *p) = 0;
    virtual void visitRelExprLe(RelExprLe *p) = 0;
    virtual void visitRelExprGe(RelExprGe *p) = 0;
    virtual void visitAddExpr(AddExpr *p) = 0;
    virtual void visitDecExpr(DecExpr *p) = 0;
    virtual void visitMulExpr(MulExpr *p) = 0;
    virtual void visitDivExpr(DivExpr *p) = 0;
    virtual void visitModExpr(ModExpr *p) = 0;
    virtual void visitNegExpr(NegExpr *p) = 0;
    virtual void visitPlusExpr(PlusExpr *p) = 0;
    virtual void visitMinusExpr(MinusExpr *p) = 0;
    virtual void visitFunctionCall(FunctionCall *p) = 0;
    virtual void visitArrayAccess(ArrayAccess *p) = 0;
    virtual void visitIdentExpr(IdentExpr *p) = 0;
    virtual void visitLiteralExpr(LiteralExpr *p) = 0;
    virtual void visitLiteralInteger(LiteralInteger *p) = 0;
    virtual void visitLiteralDouble(LiteralDouble *p) = 0;
    virtual void visitLiteralString(LiteralString *p) = 0;
    virtual void visitLiteralBoolean(LiteralBoolean *p) = 0;
    virtual void visitListFunDef(ListFunDef *p) = 0;
    virtual void visitListArg(ListArg *p) = 0;
    virtual void visitListInstr(ListInstr *p) = 0;
    virtual void visitListDecl(ListDecl *p) = 0;
    virtual void visitListExpr(ListExpr *p) = 0;


    virtual void visitInteger(Integer x) = 0;
    virtual void visitChar(Char x) = 0;
    virtual void visitDouble(Double x) = 0;
    virtual void visitString(String x) = 0;
    virtual void visitIdent(Ident x) = 0;
    virtual void visitBoolean(Boolean x) = 0;

};


class Visitable {
public:
    virtual ~Visitable() {}
    virtual void accept(Visitor *v) = 0;
};


/********************   Abstract Syntax Classes    ********************/

class Prog : public Visitable {
public:
    virtual Prog *clone() const = 0;
    int line_number;
};

class FunDef : public Visitable {
public:
    virtual FunDef *clone() const = 0;
    int line_number;
};

class Type : public Visitable {
public:
    virtual Type *clone() const = 0;
    int line_number;
    virtual JType *getJType() const = 0;
};

class Arg : public Visitable {
public:
    virtual Arg *clone() const = 0;
    int line_number;
};

class Instr : public Visitable {
public:
    virtual Instr *clone() const = 0;
    int line_number;
};

class Decl : public Visitable {
public:
    virtual Decl *clone() const = 0;
    int line_number;
};

class Expr : public Visitable {
public:
    virtual Expr *clone() const = 0;
    int line_number;
};

class Literal : public Visitable {
public:
    virtual Literal *clone() const = 0;
    int line_number;
};



class Program : public Prog {
public:
    ListFunDef *listfundef_;

    Program(const Program &);
    Program &operator=(const Program &);
    Program(ListFunDef *p1);
    ~Program();
    virtual void accept(Visitor *v);
    virtual Program *clone() const;
    void swap(Program &);
};

class Function : public FunDef {
public:
    Type *type_;
    Ident ident_;
    ListArg *listarg_;
    Instr *instr_;

    Function(const Function &);
    Function &operator=(const Function &);
    Function(Type *p1, Ident p2, ListArg *p3, Instr *p4);
    ~Function();
    virtual void accept(Visitor *v);
    virtual Function *clone() const;
    void swap(Function &);
};

class IntType : public Type {
public:

    IntType(const IntType &);
    IntType &operator=(const IntType &);
    IntType();
    ~IntType();
    virtual void accept(Visitor *v);
    virtual IntType *clone() const;
    JType* getJType() const;
    void swap(IntType &);
};

class DoubleType : public Type {
public:

    DoubleType(const DoubleType &);
    DoubleType &operator=(const DoubleType &);
    DoubleType();
    ~DoubleType();
    virtual void accept(Visitor *v);
    virtual DoubleType *clone() const;
    JType* getJType() const;
    void swap(DoubleType &);
};

class VoidType : public Type {
public:

    VoidType(const VoidType &);
    VoidType &operator=(const VoidType &);
    VoidType();
    ~VoidType();
    virtual void accept(Visitor *v);
    virtual VoidType *clone() const;
    JType* getJType() const;
    void swap(VoidType &);
};

class BoolType : public Type {
public:

    BoolType(const BoolType &);
    BoolType &operator=(const BoolType &);
    BoolType();
    ~BoolType();
    virtual void accept(Visitor *v);
    virtual BoolType *clone() const;
    void swap(BoolType &);
    JType* getJType() const;
};

class FunctionArg : public Arg {
public:
    Type *type_;
    Ident ident_;

    FunctionArg(const FunctionArg &);
    FunctionArg &operator=(const FunctionArg &);
    FunctionArg(Type *p1, Ident p2);
    ~FunctionArg();
    virtual void accept(Visitor *v);
    virtual FunctionArg *clone() const;
    void swap(FunctionArg &);
};

class CompundInstr : public Instr {
public:
    ListInstr *listinstr_;

    CompundInstr(const CompundInstr &);
    CompundInstr &operator=(const CompundInstr &);
    CompundInstr(ListInstr *p1);
    ~CompundInstr();
    virtual void accept(Visitor *v);
    virtual CompundInstr *clone() const;
    void swap(CompundInstr &);
};

class InnerFunction : public Instr {
public:
    FunDef *fundef_;

    InnerFunction(const InnerFunction &);
    InnerFunction &operator=(const InnerFunction &);
    InnerFunction(FunDef *p1);
    ~InnerFunction();
    virtual void accept(Visitor *v);
    virtual InnerFunction *clone() const;
    void swap(InnerFunction &);
};

class ReturnExpr : public Instr {
public:

    ReturnExpr(const ReturnExpr &);
    ReturnExpr &operator=(const ReturnExpr &);
    ReturnExpr();
    ~ReturnExpr();
    virtual void accept(Visitor *v);
    virtual ReturnExpr *clone() const;
    void swap(ReturnExpr &);
};

class ReturnExprInstr : public Instr {
public:
    Expr *expr_;

    ReturnExprInstr(const ReturnExprInstr &);
    ReturnExprInstr &operator=(const ReturnExprInstr &);
    ReturnExprInstr(Expr *p1);
    ~ReturnExprInstr();
    virtual void accept(Visitor *v);
    virtual ReturnExprInstr *clone() const;
    void swap(ReturnExprInstr &);
};

class DeclInstr : public Instr {
public:
    Type *type_;
    ListDecl *listdecl_;

    DeclInstr(const DeclInstr &);
    DeclInstr &operator=(const DeclInstr &);
    DeclInstr(Type *p1, ListDecl *p2);
    ~DeclInstr();
    virtual void accept(Visitor *v);
    virtual DeclInstr *clone() const;
    void swap(DeclInstr &);
};

class ConditionalIf : public Instr {
public:
    Expr *expr_;
    Instr *instr_;

    ConditionalIf(const ConditionalIf &);
    ConditionalIf &operator=(const ConditionalIf &);
    ConditionalIf(Expr *p1, Instr *p2);
    ~ConditionalIf();
    virtual void accept(Visitor *v);
    virtual ConditionalIf *clone() const;
    void swap(ConditionalIf &);
};

class ConditionalIfElse : public Instr {
public:
    Expr *expr_;
    Instr *instr_1;
    Instr *instr_2;

    ConditionalIfElse(const ConditionalIfElse &);
    ConditionalIfElse &operator=(const ConditionalIfElse &);
    ConditionalIfElse(Expr *p1, Instr *p2, Instr *p3);
    ~ConditionalIfElse();
    virtual void accept(Visitor *v);
    virtual ConditionalIfElse *clone() const;
    void swap(ConditionalIfElse &);
};

class ExpresionInstr : public Instr {
public:
    Expr *expr_;

    ExpresionInstr(const ExpresionInstr &);
    ExpresionInstr &operator=(const ExpresionInstr &);
    ExpresionInstr(Expr *p1);
    ~ExpresionInstr();
    virtual void accept(Visitor *v);
    virtual ExpresionInstr *clone() const;
    void swap(ExpresionInstr &);
};

class ForLoop : public Instr {
public:
    Decl *decl_;
    Expr *expr_1;
    Expr *expr_2;
    Instr *instr_;

    ForLoop(const ForLoop &);
    ForLoop &operator=(const ForLoop &);
    ForLoop(Decl *p1, Expr *p2, Expr *p3, Instr *p4);
    ~ForLoop();
    virtual void accept(Visitor *v);
    virtual ForLoop *clone() const;
    void swap(ForLoop &);
};

class WhileLoop : public Instr {
public:
    Expr *expr_;
    Instr *instr_;

    WhileLoop(const WhileLoop &);
    WhileLoop &operator=(const WhileLoop &);
    WhileLoop(Expr *p1, Instr *p2);
    ~WhileLoop();
    virtual void accept(Visitor *v);
    virtual WhileLoop *clone() const;
    void swap(WhileLoop &);
};

class OnlyDeclarator : public Decl {
public:
    Ident ident_;

    OnlyDeclarator(const OnlyDeclarator &);
    OnlyDeclarator &operator=(const OnlyDeclarator &);
    OnlyDeclarator(Ident p1);
    ~OnlyDeclarator();
    virtual void accept(Visitor *v);
    virtual OnlyDeclarator *clone() const;
    void swap(OnlyDeclarator &);
};

class InitDeclarator : public Decl {
public:
    Ident ident_;
    Expr *expr_;

    InitDeclarator(const InitDeclarator &);
    InitDeclarator &operator=(const InitDeclarator &);
    InitDeclarator(Ident p1, Expr *p2);
    ~InitDeclarator();
    virtual void accept(Visitor *v);
    virtual InitDeclarator *clone() const;
    void swap(InitDeclarator &);
};

class Assigment : public Expr {
public:
    Expr *expr_1;
    Expr *expr_2;

    Assigment(const Assigment &);
    Assigment &operator=(const Assigment &);
    Assigment(Expr *p1, Expr *p2);
    ~Assigment();
    virtual void accept(Visitor *v);
    virtual Assigment *clone() const;
    void swap(Assigment &);
};

class PostDecrement : public Expr {
public:
    Ident ident_;

    PostDecrement(const PostDecrement &);
    PostDecrement &operator=(const PostDecrement &);
    PostDecrement(Ident p1);
    ~PostDecrement();
    virtual void accept(Visitor *v);
    virtual PostDecrement *clone() const;
    void swap(PostDecrement &);
};

class PostIncrement : public Expr {
public:
    Ident ident_;

    PostIncrement(const PostIncrement &);
    PostIncrement &operator=(const PostIncrement &);
    PostIncrement(Ident p1);
    ~PostIncrement();
    virtual void accept(Visitor *v);
    virtual PostIncrement *clone() const;
    void swap(PostIncrement &);
};

class Cast : public Expr {
public:
    Type *type_;

    Cast(const Cast &);
    Cast &operator=(const Cast &);
    Cast(Type *p1);
    ~Cast();
    virtual void accept(Visitor *v);
    virtual Cast *clone() const;
    void swap(Cast &);
};

class LogExprOr : public Expr {
public:
    Expr *expr_1;
    Expr *expr_2;

    LogExprOr(const LogExprOr &);
    LogExprOr &operator=(const LogExprOr &);
    LogExprOr(Expr *p1, Expr *p2);
    ~LogExprOr();
    virtual void accept(Visitor *v);
    virtual LogExprOr *clone() const;
    void swap(LogExprOr &);
};

class LogExprAnd : public Expr {
public:
    Expr *expr_1;
    Expr *expr_2;

    LogExprAnd(const LogExprAnd &);
    LogExprAnd &operator=(const LogExprAnd &);
    LogExprAnd(Expr *p1, Expr *p2);
    ~LogExprAnd();
    virtual void accept(Visitor *v);
    virtual LogExprAnd *clone() const;
    void swap(LogExprAnd &);
};

class LogExprEq : public Expr {
public:
    Expr *expr_1;
    Expr *expr_2;

    LogExprEq(const LogExprEq &);
    LogExprEq &operator=(const LogExprEq &);
    LogExprEq(Expr *p1, Expr *p2);
    ~LogExprEq();
    virtual void accept(Visitor *v);
    virtual LogExprEq *clone() const;
    void swap(LogExprEq &);
};

class LogExprNeq : public Expr {
public:
    Expr *expr_1;
    Expr *expr_2;

    LogExprNeq(const LogExprNeq &);
    LogExprNeq &operator=(const LogExprNeq &);
    LogExprNeq(Expr *p1, Expr *p2);
    ~LogExprNeq();
    virtual void accept(Visitor *v);
    virtual LogExprNeq *clone() const;
    void swap(LogExprNeq &);
};

class RelExprL : public Expr {
public:
    Expr *expr_1;
    Expr *expr_2;

    RelExprL(const RelExprL &);
    RelExprL &operator=(const RelExprL &);
    RelExprL(Expr *p1, Expr *p2);
    ~RelExprL();
    virtual void accept(Visitor *v);
    virtual RelExprL *clone() const;
    void swap(RelExprL &);
};

class RelExprG : public Expr {
public:
    Expr *expr_1;
    Expr *expr_2;

    RelExprG(const RelExprG &);
    RelExprG &operator=(const RelExprG &);
    RelExprG(Expr *p1, Expr *p2);
    ~RelExprG();
    virtual void accept(Visitor *v);
    virtual RelExprG *clone() const;
    void swap(RelExprG &);
};

class RelExprLe : public Expr {
public:
    Expr *expr_1;
    Expr *expr_2;

    RelExprLe(const RelExprLe &);
    RelExprLe &operator=(const RelExprLe &);
    RelExprLe(Expr *p1, Expr *p2);
    ~RelExprLe();
    virtual void accept(Visitor *v);
    virtual RelExprLe *clone() const;
    void swap(RelExprLe &);
};

class RelExprGe : public Expr {
public:
    Expr *expr_1;
    Expr *expr_2;

    RelExprGe(const RelExprGe &);
    RelExprGe &operator=(const RelExprGe &);
    RelExprGe(Expr *p1, Expr *p2);
    ~RelExprGe();
    virtual void accept(Visitor *v);
    virtual RelExprGe *clone() const;
    void swap(RelExprGe &);
};

class AddExpr : public Expr {
public:
    Expr *expr_1;
    Expr *expr_2;

    AddExpr(const AddExpr &);
    AddExpr &operator=(const AddExpr &);
    AddExpr(Expr *p1, Expr *p2);
    ~AddExpr();
    virtual void accept(Visitor *v);
    virtual AddExpr *clone() const;
    void swap(AddExpr &);
};

class DecExpr : public Expr {
public:
    Expr *expr_1;
    Expr *expr_2;

    DecExpr(const DecExpr &);
    DecExpr &operator=(const DecExpr &);
    DecExpr(Expr *p1, Expr *p2);
    ~DecExpr();
    virtual void accept(Visitor *v);
    virtual DecExpr *clone() const;
    void swap(DecExpr &);
};

class MulExpr : public Expr {
public:
    Expr *expr_1;
    Expr *expr_2;

    MulExpr(const MulExpr &);
    MulExpr &operator=(const MulExpr &);
    MulExpr(Expr *p1, Expr *p2);
    ~MulExpr();
    virtual void accept(Visitor *v);
    virtual MulExpr *clone() const;
    void swap(MulExpr &);
};

class DivExpr : public Expr {
public:
    Expr *expr_1;
    Expr *expr_2;

    DivExpr(const DivExpr &);
    DivExpr &operator=(const DivExpr &);
    DivExpr(Expr *p1, Expr *p2);
    ~DivExpr();
    virtual void accept(Visitor *v);
    virtual DivExpr *clone() const;
    void swap(DivExpr &);
};

class ModExpr : public Expr {
public:
    Expr *expr_1;
    Expr *expr_2;

    ModExpr(const ModExpr &);
    ModExpr &operator=(const ModExpr &);
    ModExpr(Expr *p1, Expr *p2);
    ~ModExpr();
    virtual void accept(Visitor *v);
    virtual ModExpr *clone() const;
    void swap(ModExpr &);
};

class NegExpr : public Expr {
public:
    Expr *expr_;

    NegExpr(const NegExpr &);
    NegExpr &operator=(const NegExpr &);
    NegExpr(Expr *p1);
    ~NegExpr();
    virtual void accept(Visitor *v);
    virtual NegExpr *clone() const;
    void swap(NegExpr &);
};

class PlusExpr : public Expr {
public:
    Expr *expr_;

    PlusExpr(const PlusExpr &);
    PlusExpr &operator=(const PlusExpr &);
    PlusExpr(Expr *p1);
    ~PlusExpr();
    virtual void accept(Visitor *v);
    virtual PlusExpr *clone() const;
    void swap(PlusExpr &);
};

class MinusExpr : public Expr {
public:
    Expr *expr_;

    MinusExpr(const MinusExpr &);
    MinusExpr &operator=(const MinusExpr &);
    MinusExpr(Expr *p1);
    ~MinusExpr();
    virtual void accept(Visitor *v);
    virtual MinusExpr *clone() const;
    void swap(MinusExpr &);
};

class FunctionCall : public Expr {
public:
    Ident ident_;
    ListExpr *listexpr_;

    FunctionCall(const FunctionCall &);
    FunctionCall &operator=(const FunctionCall &);
    FunctionCall(Ident p1, ListExpr *p2);
    ~FunctionCall();
    virtual void accept(Visitor *v);
    virtual FunctionCall *clone() const;
    void swap(FunctionCall &);
};

class ArrayAccess : public Expr {
public:
    Ident ident_;
    Expr *expr_;

    ArrayAccess(const ArrayAccess &);
    ArrayAccess &operator=(const ArrayAccess &);
    ArrayAccess(Ident p1, Expr *p2);
    ~ArrayAccess();
    virtual void accept(Visitor *v);
    virtual ArrayAccess *clone() const;
    void swap(ArrayAccess &);
};

class IdentExpr : public Expr {
public:
    Ident ident_;

    IdentExpr(const IdentExpr &);
    IdentExpr &operator=(const IdentExpr &);
    IdentExpr(Ident p1);
    ~IdentExpr();
    virtual void accept(Visitor *v);
    virtual IdentExpr *clone() const;
    void swap(IdentExpr &);
};

class LiteralExpr : public Expr {
public:
    Literal *literal_;

    LiteralExpr(const LiteralExpr &);
    LiteralExpr &operator=(const LiteralExpr &);
    LiteralExpr(Literal *p1);
    ~LiteralExpr();
    virtual void accept(Visitor *v);
    virtual LiteralExpr *clone() const;
    void swap(LiteralExpr &);
};

class LiteralInteger : public Literal {
public:
    Integer integer_;

    LiteralInteger(const LiteralInteger &);
    LiteralInteger &operator=(const LiteralInteger &);
    LiteralInteger(Integer p1);
    ~LiteralInteger();
    virtual void accept(Visitor *v);
    virtual LiteralInteger *clone() const;
    void swap(LiteralInteger &);
};

class LiteralDouble : public Literal {
public:
    Double double_;

    LiteralDouble(const LiteralDouble &);
    LiteralDouble &operator=(const LiteralDouble &);
    LiteralDouble(Double p1);
    ~LiteralDouble();
    virtual void accept(Visitor *v);
    virtual LiteralDouble *clone() const;
    void swap(LiteralDouble &);
};

class LiteralString : public Literal {
public:
    String string_;

    LiteralString(const LiteralString &);
    LiteralString &operator=(const LiteralString &);
    LiteralString(String p1);
    ~LiteralString();
    virtual void accept(Visitor *v);
    virtual LiteralString *clone() const;
    void swap(LiteralString &);
};

class LiteralBoolean : public Literal {
public:
    Boolean boolean_;

    LiteralBoolean(const LiteralBoolean &);
    LiteralBoolean &operator=(const LiteralBoolean &);
    LiteralBoolean(Boolean p1);
    ~LiteralBoolean();
    virtual void accept(Visitor *v);
    virtual LiteralBoolean *clone() const;
    void swap(LiteralBoolean &);
};



class ListFunDef : public Visitable, public std::vector<FunDef*> {
public:
    virtual void accept(Visitor *v);
    virtual ListFunDef *clone() const;
};

class ListArg : public Visitable, public std::vector<Arg*> {
public:
    virtual void accept(Visitor *v);
    virtual ListArg *clone() const;
};

class ListInstr : public Visitable, public std::vector<Instr*> {
public:
    virtual void accept(Visitor *v);
    virtual ListInstr *clone() const;
};

class ListDecl : public Visitable, public std::vector<Decl*> {
public:
    virtual void accept(Visitor *v);
    virtual ListDecl *clone() const;
};

class ListExpr : public Visitable, public std::vector<Expr*> {
public:
    virtual void accept(Visitor *v);
    virtual ListExpr *clone() const;
};



#endif
