#ifndef ABSYN_HEADER
#define ABSYN_HEADER

#include<string>
#include<vector>

#include "llvm/DerivedTypes.h"
#include "llvm/Function.h"
#include "JType.H"

//C++ Abstract Syntax Interface generated by the BNF Converter.

/********************   TypeDef Section    ********************/

typedef int Integer;
typedef char Char;
typedef double Double;
typedef std::string String;
typedef std::string Ident;


typedef std::string Boolean;


/********************   Forward Declarations    ********************/

class Prog;
class FunDef;
class Type;
class Arg;
class Instr;
class Decl;
class Expr;
class Literal;
class Program;
class Function;
class IntType;
class DoubleType;
class VoidType;
class BoolType;
class FunctionArg;
class CompoundInstr;
class InnerFunction;
class ReturnInstr;
class ReturnExprInstr;
class DeclInstr;
class ConditionalIf;
class ConditionalIfElse;
class ExpressionInstr;
class ForLoop;
class WhileLoop;
class OnlyDeclarator;
class InitDeclarator;
class ArrayDeclarator;
class IdentAssigment;
class ArrayAssigment;
class PostDecrement;
class PostIncrement;
class Cast;
class LogExprOr;
class LogExprAnd;
class LogExprEq;
class LogExprNeq;
class RelExprL;
class RelExprG;
class RelExprLe;
class RelExprGe;
class AddExpr;
class DecExpr;
class MulExpr;
class DivExpr;
class ModExpr;
class NegExpr;
class PlusExpr;
class MinusExpr;
class FunctionCall;
class ArrayAccess;
class IdentExpr;
class LiteralExpr;
class LiteralInteger;
class LiteralDouble;
class LiteralString;
class LiteralBoolean;
class ListFunDef;
class ListArg;
class ListInstr;
class ListDecl;
class ListExpr;


/********************   Visitor Interfaces    ********************/
class Visitor
{
public:
  virtual ~Visitor() {}
  virtual void visitProg(Prog *p) = 0;
  virtual void visitFunDef(FunDef *p) = 0;
  virtual void visitType(Type *p) = 0;
  virtual void visitArg(Arg *p) = 0;
  virtual void visitInstr(Instr *p) = 0;
  virtual void visitDecl(Decl *p) = 0;
  virtual void visitExpr(Expr *p) = 0;
  virtual void visitLiteral(Literal *p) = 0;
  virtual void visitProgram(Program *p) = 0;
  virtual void visitFunction(Function *p) = 0;
  virtual void visitIntType(IntType *p) = 0;
  virtual void visitDoubleType(DoubleType *p) = 0;
  virtual void visitVoidType(VoidType *p) = 0;
  virtual void visitBoolType(BoolType *p) = 0;
  virtual void visitFunctionArg(FunctionArg *p) = 0;
  virtual void visitCompoundInstr(CompoundInstr *p) = 0;
  virtual void visitInnerFunction(InnerFunction *p) = 0;
  virtual void visitReturnInstr(ReturnInstr *p) = 0;
  virtual void visitReturnExprInstr(ReturnExprInstr *p) = 0;
  virtual void visitDeclInstr(DeclInstr *p) = 0;
  virtual void visitConditionalIf(ConditionalIf *p) = 0;
  virtual void visitConditionalIfElse(ConditionalIfElse *p) = 0;
  virtual void visitExpressionInstr(ExpressionInstr *p) = 0;
  virtual void visitForLoop(ForLoop *p) = 0;
  virtual void visitWhileLoop(WhileLoop *p) = 0;
  virtual void visitOnlyDeclarator(OnlyDeclarator *p) = 0;
  virtual void visitInitDeclarator(InitDeclarator *p) = 0;
  virtual void visitArrayDeclarator(ArrayDeclarator *p) = 0;
  virtual void visitIdentAssigment(IdentAssigment *p) = 0;
  virtual void visitArrayAssigment(ArrayAssigment *p) = 0;
  virtual void visitPostDecrement(PostDecrement *p) = 0;
  virtual void visitPostIncrement(PostIncrement *p) = 0;
  virtual void visitCast(Cast *p) = 0;
  virtual void visitLogExprOr(LogExprOr *p) = 0;
  virtual void visitLogExprAnd(LogExprAnd *p) = 0;
  virtual void visitLogExprEq(LogExprEq *p) = 0;
  virtual void visitLogExprNeq(LogExprNeq *p) = 0;
  virtual void visitRelExprL(RelExprL *p) = 0;
  virtual void visitRelExprG(RelExprG *p) = 0;
  virtual void visitRelExprLe(RelExprLe *p) = 0;
  virtual void visitRelExprGe(RelExprGe *p) = 0;
  virtual void visitAddExpr(AddExpr *p) = 0;
  virtual void visitDecExpr(DecExpr *p) = 0;
  virtual void visitMulExpr(MulExpr *p) = 0;
  virtual void visitDivExpr(DivExpr *p) = 0;
  virtual void visitModExpr(ModExpr *p) = 0;
  virtual void visitNegExpr(NegExpr *p) = 0;
  virtual void visitPlusExpr(PlusExpr *p) = 0;
  virtual void visitMinusExpr(MinusExpr *p) = 0;
  virtual void visitFunctionCall(FunctionCall *p) = 0;
  virtual void visitArrayAccess(ArrayAccess *p) = 0;
  virtual void visitIdentExpr(IdentExpr *p) = 0;
  virtual void visitLiteralExpr(LiteralExpr *p) = 0;
  virtual void visitLiteralInteger(LiteralInteger *p) = 0;
  virtual void visitLiteralDouble(LiteralDouble *p) = 0;
  virtual void visitLiteralString(LiteralString *p) = 0;
  virtual void visitLiteralBoolean(LiteralBoolean *p) = 0;
  virtual void visitListFunDef(ListFunDef *p) = 0;
  virtual void visitListArg(ListArg *p) = 0;
  virtual void visitListInstr(ListInstr *p) = 0;
  virtual void visitListDecl(ListDecl *p) = 0;
  virtual void visitListExpr(ListExpr *p) = 0;


  virtual void visitInteger(Integer x) = 0;
  virtual void visitChar(Char x) = 0;
  virtual void visitDouble(Double x) = 0;
  virtual void visitString(String x) = 0;
  virtual void visitIdent(Ident x) = 0;
  virtual void visitBoolean(Boolean x) = 0;

};


class CodeGeneratorVisitor {
public:
    virtual ~CodeGeneratorVisitor() {}
    virtual llvm::Value* visitProg(Prog *p) = 0;
    virtual llvm::Value* visitFunDef(FunDef *p) = 0;
    virtual llvm::Value* visitType(Type *p) = 0;
    virtual llvm::Value* visitArg(Arg *p) = 0;
    virtual llvm::Value* visitInstr(Instr *p) = 0;
    virtual llvm::Value* visitDecl(Decl *p) = 0;
    virtual llvm::Value* visitExpr(Expr *p) = 0;
    virtual llvm::Value* visitLiteral(Literal *p) = 0;
    virtual llvm::Value* visitProgram(Program *p) = 0;
    virtual llvm::Value* visitFunction(Function *p) = 0;
    virtual llvm::Value* visitIntType(IntType *p) = 0;
    virtual llvm::Value* visitDoubleType(DoubleType *p) = 0;
    virtual llvm::Value* visitVoidType(VoidType *p) = 0;
    virtual llvm::Value* visitBoolType(BoolType *p) = 0;
    virtual llvm::Value* visitFunctionArg(FunctionArg *p) = 0;
    virtual llvm::Value* visitCompoundInstr(CompoundInstr *p) = 0;
    virtual llvm::Value* visitInnerFunction(InnerFunction *p) = 0;
    virtual llvm::Value* visitReturnInstr(ReturnInstr *p) = 0;
    virtual llvm::Value* visitReturnExprInstr(ReturnExprInstr *p) = 0;
    virtual llvm::Value* visitDeclInstr(DeclInstr *p) = 0;
    virtual llvm::Value* visitConditionalIf(ConditionalIf *p) = 0;
    virtual llvm::Value* visitConditionalIfElse(ConditionalIfElse *p) = 0;
    virtual llvm::Value* visitExpressionInstr(ExpressionInstr *p) = 0;
    virtual llvm::Value* visitForLoop(ForLoop *p) = 0;
    virtual llvm::Value* visitWhileLoop(WhileLoop *p) = 0;
    virtual llvm::Value* visitOnlyDeclarator(const llvm::Type*, OnlyDeclarator*) = 0;
    virtual llvm::Value* visitInitDeclarator(const llvm::Type*, InitDeclarator*) = 0;
    virtual llvm::Value* visitArrayDeclarator(const llvm::Type*, ArrayDeclarator*) = 0;
    virtual llvm::Value* visitIdentAssigment(IdentAssigment *p) = 0;
    virtual llvm::Value* visitArrayAssigment(ArrayAssigment *p) = 0;
    virtual llvm::Value* visitPostDecrement(PostDecrement *p) = 0;
    virtual llvm::Value* visitPostIncrement(PostIncrement *p) = 0;
    virtual llvm::Value* visitCast(Cast *p) = 0;
    virtual llvm::Value* visitLogExprOr(LogExprOr *p) = 0;
    virtual llvm::Value* visitLogExprAnd(LogExprAnd *p) = 0;
    virtual llvm::Value* visitLogExprEq(LogExprEq *p) = 0;
    virtual llvm::Value* visitLogExprNeq(LogExprNeq *p) = 0;
    virtual llvm::Value* visitRelExprL(RelExprL *p) = 0;
    virtual llvm::Value* visitRelExprG(RelExprG *p) = 0;
    virtual llvm::Value* visitRelExprLe(RelExprLe *p) = 0;
    virtual llvm::Value* visitRelExprGe(RelExprGe *p) = 0;
    virtual llvm::Value* visitAddExpr(AddExpr *p) = 0;
    virtual llvm::Value* visitDecExpr(DecExpr *p) = 0;
    virtual llvm::Value* visitMulExpr(MulExpr *p) = 0;
    virtual llvm::Value* visitDivExpr(DivExpr *p) = 0;
    virtual llvm::Value* visitModExpr(ModExpr *p) = 0;
    virtual llvm::Value* visitNegExpr(NegExpr *p) = 0;
    virtual llvm::Value* visitPlusExpr(PlusExpr *p) = 0;
    virtual llvm::Value* visitMinusExpr(MinusExpr *p) = 0;
    virtual llvm::Value* visitFunctionCall(FunctionCall *p) = 0;
    virtual llvm::Value* visitArrayAccess(ArrayAccess *p) = 0;
    virtual llvm::Value* visitIdentExpr(IdentExpr *p) = 0;
    virtual llvm::Value* visitLiteralExpr(LiteralExpr *p) = 0;
    virtual llvm::Value* visitLiteralInteger(LiteralInteger *p) = 0;
    virtual llvm::Value* visitLiteralDouble(LiteralDouble *p) = 0;
    virtual llvm::Value* visitLiteralString(LiteralString *p) = 0;
    virtual llvm::Value* visitLiteralBoolean(LiteralBoolean *p) = 0;
    virtual llvm::Value* visitListFunDef(ListFunDef *p) = 0;
    virtual llvm::Value* visitListArg(ListArg *p) = 0;
    virtual llvm::Value* visitListInstr(ListInstr *p) = 0;
    virtual llvm::Value* visitListDecl(const llvm::Type*, ListDecl *p) = 0;
    virtual llvm::Value* visitListExpr(ListExpr *p, llvm::Function*) = 0;


    virtual llvm::Value* visitInteger(Integer x) = 0;
    virtual llvm::Value* visitChar(Char x) = 0;
    virtual llvm::Value* visitDouble(Double x) = 0;
    virtual llvm::Value* visitString(String x) = 0;
    virtual llvm::Value* visitIdent(Ident x) = 0;
    virtual llvm::Value* visitBoolean(Boolean x) = 0;

};

class Visitable {
public:
    virtual ~Visitable() {}
    virtual void accept(Visitor *v) = 0;
    virtual llvm::Value* genCode(CodeGeneratorVisitor*) = 0;
};


/********************   Abstract Syntax Classes    ********************/

class Prog : public Visitable
{
public:
  virtual Prog *clone() const = 0;
  int line_number;
};

class FunDef : public Visitable
{
public:
  virtual FunDef *clone() const = 0;
  int line_number;
};

class Type : public Visitable
{
public:
  virtual Type *clone() const = 0;
  virtual const llvm::Type* getLLVMType() const = 0;
  virtual JType* getJType() const = 0;
  int line_number;
};

class Arg : public Visitable
{
public:
  virtual Arg *clone() const = 0;
  int line_number;
};

class Instr : public Visitable
{
public:
  virtual Instr *clone() const = 0;
  int line_number;
};

class Decl : public Visitable
{
public:
  virtual Decl *clone() const = 0;
  virtual llvm::Value* genCodeWithType(const llvm::Type*, CodeGeneratorVisitor*) = 0;
  int line_number;
};

class Expr : public Visitable
{
public:
  virtual Expr *clone() const = 0;
  JType* jtype_;
  int line_number;
};

class Literal : public Visitable
{
public:
  virtual Literal *clone() const = 0;
  JType* jtype_;
  int line_number;
};



class Program : public Prog
{
public:
  ListFunDef *listfundef_;

  Program(const Program &);
  Program &operator=(const Program &);
  Program(ListFunDef *p1);
  llvm::Value* genCode(CodeGeneratorVisitor*);
  ~Program();
  virtual void accept(Visitor *v);
  virtual Program *clone() const;
  void swap(Program &);
};

class Function : public FunDef
{
public:
  Type *type_;
  Ident ident_;
  ListArg *listarg_;
  Instr *instr_;

  Function(const Function &);
  Function &operator=(const Function &);
  Function(Type *p1, Ident p2, ListArg *p3, Instr *p4);
  llvm::Value* genCode(CodeGeneratorVisitor*);
  ~Function();
  virtual void accept(Visitor *v);
  virtual Function *clone() const;
  void swap(Function &);
};

class IntType : public Type
{
public:

  IntType(const IntType &);
  IntType &operator=(const IntType &);
  IntType();
  llvm::Value* genCode(CodeGeneratorVisitor*);
  ~IntType();
  JType* getJType() const;
  const llvm::Type* getLLVMType() const;

  virtual void accept(Visitor *v);
  virtual IntType *clone() const;
  void swap(IntType &);
};

class DoubleType : public Type
{
public:

  DoubleType(const DoubleType &);
  DoubleType &operator=(const DoubleType &);
  DoubleType();
  llvm::Value* genCode(CodeGeneratorVisitor*);
  ~DoubleType();
  JType* getJType() const;
  const llvm::Type* getLLVMType() const;

  virtual void accept(Visitor *v);
  virtual DoubleType *clone() const;
  void swap(DoubleType &);
};

class VoidType : public Type
{
public:

  VoidType(const VoidType &);
  VoidType &operator=(const VoidType &);
  VoidType();
  llvm::Value* genCode(CodeGeneratorVisitor*);
  ~VoidType();
  JType* getJType() const;
  const llvm::Type* getLLVMType() const;

  virtual void accept(Visitor *v);
  virtual VoidType *clone() const;
  void swap(VoidType &);
};

class BoolType : public Type
{
public:

  BoolType(const BoolType &);
  BoolType &operator=(const BoolType &);
  BoolType();
  llvm::Value* genCode(CodeGeneratorVisitor*);
  ~BoolType();
  JType* getJType() const;
  const llvm::Type* getLLVMType() const;

  virtual void accept(Visitor *v);
  virtual BoolType *clone() const;
  void swap(BoolType &);
};

class FunctionArg : public Arg
{
public:
  Type *type_;
  Ident ident_;

  FunctionArg(const FunctionArg &);
  FunctionArg &operator=(const FunctionArg &);
  FunctionArg(Type *p1, Ident p2);
  llvm::Value* genCode(CodeGeneratorVisitor*);
  ~FunctionArg();
  virtual void accept(Visitor *v);
  virtual FunctionArg *clone() const;
  void swap(FunctionArg &);
};

class CompoundInstr : public Instr
{
public:
  ListInstr *listinstr_;

  CompoundInstr(const CompoundInstr &);
  CompoundInstr &operator=(const CompoundInstr &);
  CompoundInstr(ListInstr *p1);
  llvm::Value* genCode(CodeGeneratorVisitor*);
  ~CompoundInstr();
  virtual void accept(Visitor *v);
  virtual CompoundInstr *clone() const;
  void swap(CompoundInstr &);
};

class InnerFunction : public Instr
{
public:
  FunDef *fundef_;

  InnerFunction(const InnerFunction &);
  InnerFunction &operator=(const InnerFunction &);
  InnerFunction(FunDef *p1);
  llvm::Value* genCode(CodeGeneratorVisitor*);
  ~InnerFunction();
  virtual void accept(Visitor *v);
  virtual InnerFunction *clone() const;
  void swap(InnerFunction &);
};

class ReturnInstr : public Instr
{
public:

  ReturnInstr(const ReturnInstr &);
  ReturnInstr &operator=(const ReturnInstr &);
  ReturnInstr();
  llvm::Value* genCode(CodeGeneratorVisitor*);
  ~ReturnInstr();
  virtual void accept(Visitor *v);
  virtual ReturnInstr *clone() const;
  void swap(ReturnInstr &);
};

class ReturnExprInstr : public Instr
{
public:
  Expr *expr_;

  ReturnExprInstr(const ReturnExprInstr &);
  ReturnExprInstr &operator=(const ReturnExprInstr &);
  ReturnExprInstr(Expr *p1);
  llvm::Value* genCode(CodeGeneratorVisitor*);
  ~ReturnExprInstr();
  virtual void accept(Visitor *v);
  virtual ReturnExprInstr *clone() const;
  void swap(ReturnExprInstr &);
};

class DeclInstr : public Instr
{
public:
  Type *type_;
  ListDecl *listdecl_;

  DeclInstr(const DeclInstr &);
  DeclInstr &operator=(const DeclInstr &);
  DeclInstr(Type *p1, ListDecl *p2);
  llvm::Value* genCode(CodeGeneratorVisitor*);
  ~DeclInstr();
  virtual void accept(Visitor *v);
  virtual DeclInstr *clone() const;
  void swap(DeclInstr &);
};

class ConditionalIf : public Instr
{
public:
  Expr *expr_;
  Instr *instr_;

  ConditionalIf(const ConditionalIf &);
  ConditionalIf &operator=(const ConditionalIf &);
  ConditionalIf(Expr *p1, Instr *p2);
  llvm::Value* genCode(CodeGeneratorVisitor*);
  ~ConditionalIf();
  virtual void accept(Visitor *v);
  virtual ConditionalIf *clone() const;
  void swap(ConditionalIf &);
};

class ConditionalIfElse : public Instr
{
public:
  Expr *expr_;
  Instr *instr_1;
  Instr *instr_2;

  ConditionalIfElse(const ConditionalIfElse &);
  ConditionalIfElse &operator=(const ConditionalIfElse &);
  ConditionalIfElse(Expr *p1, Instr *p2, Instr *p3);
  llvm::Value* genCode(CodeGeneratorVisitor*);
  ~ConditionalIfElse();
  virtual void accept(Visitor *v);
  virtual ConditionalIfElse *clone() const;
  void swap(ConditionalIfElse &);
};

class ExpressionInstr : public Instr
{
public:
  Expr *expr_;

  ExpressionInstr(const ExpressionInstr &);
  ExpressionInstr &operator=(const ExpressionInstr &);
  ExpressionInstr(Expr *p1);
  llvm::Value* genCode(CodeGeneratorVisitor*);
  ~ExpressionInstr();
  virtual void accept(Visitor *v);
  virtual ExpressionInstr *clone() const;
  void swap(ExpressionInstr &);
};

class ForLoop : public Instr
{
public:
  ListExpr *listexpr_1;
  ListExpr *listexpr_2;
  ListExpr *listexpr_3;
  Instr *instr_;

  ForLoop(const ForLoop &);
  ForLoop &operator=(const ForLoop &);
  ForLoop(ListExpr *p1, ListExpr *p2, ListExpr *p3, Instr *p4);
  llvm::Value* genCode(CodeGeneratorVisitor*);
  ~ForLoop();
  virtual void accept(Visitor *v);
  virtual ForLoop *clone() const;
  void swap(ForLoop &);
};

class WhileLoop : public Instr
{
public:
  Expr *expr_;
  Instr *instr_;

  WhileLoop(const WhileLoop &);
  WhileLoop &operator=(const WhileLoop &);
  WhileLoop(Expr *p1, Instr *p2);
  llvm::Value* genCode(CodeGeneratorVisitor*);
  ~WhileLoop();
  virtual void accept(Visitor *v);
  virtual WhileLoop *clone() const;
  void swap(WhileLoop &);
};

class OnlyDeclarator : public Decl
{
public:
  Ident ident_;

  OnlyDeclarator(const OnlyDeclarator &);
  OnlyDeclarator &operator=(const OnlyDeclarator &);
  OnlyDeclarator(Ident p1);
  llvm::Value* genCode(CodeGeneratorVisitor*);
  llvm::Value* genCodeWithType(const llvm::Type*, CodeGeneratorVisitor*);
  ~OnlyDeclarator();
  virtual void accept(Visitor *v);
  virtual OnlyDeclarator *clone() const;
  void swap(OnlyDeclarator &);
};

class InitDeclarator : public Decl
{
public:
  Ident ident_;
  Expr *expr_;

  InitDeclarator(const InitDeclarator &);
  InitDeclarator &operator=(const InitDeclarator &);
  InitDeclarator(Ident p1, Expr *p2);
  llvm::Value* genCode(CodeGeneratorVisitor*);
  llvm::Value* genCodeWithType(const llvm::Type*, CodeGeneratorVisitor*);
  ~InitDeclarator();
  virtual void accept(Visitor *v);
  virtual InitDeclarator *clone() const;
  void swap(InitDeclarator &);
};

class ArrayDeclarator : public Decl
{
public:
  Ident ident_;
  Expr *expr_;

  ArrayDeclarator(const ArrayDeclarator &);
  ArrayDeclarator &operator=(const ArrayDeclarator &);
  ArrayDeclarator(Ident p1, Expr *p2);
  llvm::Value* genCode(CodeGeneratorVisitor*);
  llvm::Value* genCodeWithType(const llvm::Type*, CodeGeneratorVisitor*);
  ~ArrayDeclarator();
  virtual void accept(Visitor *v);
  virtual ArrayDeclarator *clone() const;
  void swap(ArrayDeclarator &);
};

class IdentAssigment : public Expr
{
public:
  Ident ident_;
  Expr *expr_;

  IdentAssigment(const IdentAssigment &);
  IdentAssigment &operator=(const IdentAssigment &);
  IdentAssigment(Ident p1, Expr *p2);
  llvm::Value* genCode(CodeGeneratorVisitor*);
  ~IdentAssigment();
  virtual void accept(Visitor *v);
  virtual IdentAssigment *clone() const;
  void swap(IdentAssigment &);
};

class ArrayAssigment : public Expr
{
public:
  Ident ident_;
  Expr *expr_1;
  Expr *expr_2;

  ArrayAssigment(const ArrayAssigment &);
  ArrayAssigment &operator=(const ArrayAssigment &);
  ArrayAssigment(Ident p1, Expr *p2, Expr *p3);
  llvm::Value* genCode(CodeGeneratorVisitor*);
  ~ArrayAssigment();
  virtual void accept(Visitor *v);
  virtual ArrayAssigment *clone() const;
  void swap(ArrayAssigment &);
};

class PostDecrement : public Expr
{
public:
  Ident ident_;

  PostDecrement(const PostDecrement &);
  PostDecrement &operator=(const PostDecrement &);
  PostDecrement(Ident p1);
  llvm::Value* genCode(CodeGeneratorVisitor*);
  ~PostDecrement();
  virtual void accept(Visitor *v);
  virtual PostDecrement *clone() const;
  void swap(PostDecrement &);
};

class PostIncrement : public Expr
{
public:
  Ident ident_;

  PostIncrement(const PostIncrement &);
  PostIncrement &operator=(const PostIncrement &);
  PostIncrement(Ident p1);
  llvm::Value* genCode(CodeGeneratorVisitor*);
  ~PostIncrement();
  virtual void accept(Visitor *v);
  virtual PostIncrement *clone() const;
  void swap(PostIncrement &);
};

class Cast : public Expr
{
public:
  Type *type_;
  Expr *expr_;

  Cast(const Cast &);
  Cast &operator=(const Cast &);
  Cast(Type *p1, Expr *p2);
  llvm::Value* genCode(CodeGeneratorVisitor*);
  ~Cast();
  virtual void accept(Visitor *v);
  virtual Cast *clone() const;
  void swap(Cast &);
};

class LogExprOr : public Expr
{
public:
  Expr *expr_1;
  Expr *expr_2;

  LogExprOr(const LogExprOr &);
  LogExprOr &operator=(const LogExprOr &);
  LogExprOr(Expr *p1, Expr *p2);
  llvm::Value* genCode(CodeGeneratorVisitor*);
  ~LogExprOr();
  virtual void accept(Visitor *v);
  virtual LogExprOr *clone() const;
  void swap(LogExprOr &);
};

class LogExprAnd : public Expr
{
public:
  Expr *expr_1;
  Expr *expr_2;

  LogExprAnd(const LogExprAnd &);
  LogExprAnd &operator=(const LogExprAnd &);
  LogExprAnd(Expr *p1, Expr *p2);
  llvm::Value* genCode(CodeGeneratorVisitor*);
  ~LogExprAnd();
  virtual void accept(Visitor *v);
  virtual LogExprAnd *clone() const;
  void swap(LogExprAnd &);
};

class LogExprEq : public Expr
{
public:
  Expr *expr_1;
  Expr *expr_2;

  LogExprEq(const LogExprEq &);
  LogExprEq &operator=(const LogExprEq &);
  LogExprEq(Expr *p1, Expr *p2);
  llvm::Value* genCode(CodeGeneratorVisitor*);
  ~LogExprEq();
  virtual void accept(Visitor *v);
  virtual LogExprEq *clone() const;
  void swap(LogExprEq &);
};

class LogExprNeq : public Expr
{
public:
  Expr *expr_1;
  Expr *expr_2;

  LogExprNeq(const LogExprNeq &);
  LogExprNeq &operator=(const LogExprNeq &);
  LogExprNeq(Expr *p1, Expr *p2);
  llvm::Value* genCode(CodeGeneratorVisitor*);
  ~LogExprNeq();
  virtual void accept(Visitor *v);
  virtual LogExprNeq *clone() const;
  void swap(LogExprNeq &);
};

class RelExprL : public Expr
{
public:
  Expr *expr_1;
  Expr *expr_2;

  RelExprL(const RelExprL &);
  RelExprL &operator=(const RelExprL &);
  RelExprL(Expr *p1, Expr *p2);
  llvm::Value* genCode(CodeGeneratorVisitor*);
  ~RelExprL();
  virtual void accept(Visitor *v);
  virtual RelExprL *clone() const;
  void swap(RelExprL &);
};

class RelExprG : public Expr
{
public:
  Expr *expr_1;
  Expr *expr_2;

  RelExprG(const RelExprG &);
  RelExprG &operator=(const RelExprG &);
  RelExprG(Expr *p1, Expr *p2);
  llvm::Value* genCode(CodeGeneratorVisitor*);
  ~RelExprG();
  virtual void accept(Visitor *v);
  virtual RelExprG *clone() const;
  void swap(RelExprG &);
};

class RelExprLe : public Expr
{
public:
  Expr *expr_1;
  Expr *expr_2;

  RelExprLe(const RelExprLe &);
  RelExprLe &operator=(const RelExprLe &);
  RelExprLe(Expr *p1, Expr *p2);
  llvm::Value* genCode(CodeGeneratorVisitor*);
  ~RelExprLe();
  virtual void accept(Visitor *v);
  virtual RelExprLe *clone() const;
  void swap(RelExprLe &);
};

class RelExprGe : public Expr
{
public:
  Expr *expr_1;
  Expr *expr_2;

  RelExprGe(const RelExprGe &);
  RelExprGe &operator=(const RelExprGe &);
  RelExprGe(Expr *p1, Expr *p2);
  llvm::Value* genCode(CodeGeneratorVisitor*);
  ~RelExprGe();
  virtual void accept(Visitor *v);
  virtual RelExprGe *clone() const;
  void swap(RelExprGe &);
};

class AddExpr : public Expr
{
public:
  Expr *expr_1;
  Expr *expr_2;

  AddExpr(const AddExpr &);
  AddExpr &operator=(const AddExpr &);
  AddExpr(Expr *p1, Expr *p2);
  llvm::Value* genCode(CodeGeneratorVisitor*);
  ~AddExpr();
  virtual void accept(Visitor *v);
  virtual AddExpr *clone() const;
  void swap(AddExpr &);
};

class DecExpr : public Expr
{
public:
  Expr *expr_1;
  Expr *expr_2;

  DecExpr(const DecExpr &);
  DecExpr &operator=(const DecExpr &);
  DecExpr(Expr *p1, Expr *p2);
  llvm::Value* genCode(CodeGeneratorVisitor*);
  ~DecExpr();
  virtual void accept(Visitor *v);
  virtual DecExpr *clone() const;
  void swap(DecExpr &);
};

class MulExpr : public Expr
{
public:
  Expr *expr_1;
  Expr *expr_2;

  MulExpr(const MulExpr &);
  MulExpr &operator=(const MulExpr &);
  MulExpr(Expr *p1, Expr *p2);
  llvm::Value* genCode(CodeGeneratorVisitor*);
  ~MulExpr();
  virtual void accept(Visitor *v);
  virtual MulExpr *clone() const;
  void swap(MulExpr &);
};

class DivExpr : public Expr
{
public:
  Expr *expr_1;
  Expr *expr_2;

  DivExpr(const DivExpr &);
  DivExpr &operator=(const DivExpr &);
  DivExpr(Expr *p1, Expr *p2);
  llvm::Value* genCode(CodeGeneratorVisitor*);
  ~DivExpr();
  virtual void accept(Visitor *v);
  virtual DivExpr *clone() const;
  void swap(DivExpr &);
};

class ModExpr : public Expr
{
public:
  Expr *expr_1;
  Expr *expr_2;

  ModExpr(const ModExpr &);
  ModExpr &operator=(const ModExpr &);
  ModExpr(Expr *p1, Expr *p2);
  llvm::Value* genCode(CodeGeneratorVisitor*);
  ~ModExpr();
  virtual void accept(Visitor *v);
  virtual ModExpr *clone() const;
  void swap(ModExpr &);
};

class NegExpr : public Expr
{
public:
  Expr *expr_;

  NegExpr(const NegExpr &);
  NegExpr &operator=(const NegExpr &);
  NegExpr(Expr *p1);
  llvm::Value* genCode(CodeGeneratorVisitor*);
  ~NegExpr();
  virtual void accept(Visitor *v);
  virtual NegExpr *clone() const;
  void swap(NegExpr &);
};

class PlusExpr : public Expr
{
public:
  Expr *expr_;

  PlusExpr(const PlusExpr &);
  PlusExpr &operator=(const PlusExpr &);
  PlusExpr(Expr *p1);
  llvm::Value* genCode(CodeGeneratorVisitor*);
  ~PlusExpr();
  virtual void accept(Visitor *v);
  virtual PlusExpr *clone() const;
  void swap(PlusExpr &);
};

class MinusExpr : public Expr
{
public:
  Expr *expr_;

  MinusExpr(const MinusExpr &);
  MinusExpr &operator=(const MinusExpr &);
  MinusExpr(Expr *p1);
  llvm::Value* genCode(CodeGeneratorVisitor*);
  ~MinusExpr();
  virtual void accept(Visitor *v);
  virtual MinusExpr *clone() const;
  void swap(MinusExpr &);
};

class FunctionCall : public Expr
{
public:
  Ident ident_;
  ListExpr *listexpr_;

  FunctionCall(const FunctionCall &);
  FunctionCall &operator=(const FunctionCall &);
  FunctionCall(Ident p1, ListExpr *p2);
  llvm::Value* genCode(CodeGeneratorVisitor*);
  ~FunctionCall();
  virtual void accept(Visitor *v);
  virtual FunctionCall *clone() const;
  void swap(FunctionCall &);
};

class ArrayAccess : public Expr
{
public:
  Ident ident_;
  Expr *expr_;

  ArrayAccess(const ArrayAccess &);
  ArrayAccess &operator=(const ArrayAccess &);
  ArrayAccess(Ident p1, Expr *p2);
  llvm::Value* genCode(CodeGeneratorVisitor*);
  ~ArrayAccess();
  virtual void accept(Visitor *v);
  virtual ArrayAccess *clone() const;
  void swap(ArrayAccess &);
};

class IdentExpr : public Expr
{
public:
  Ident ident_;

  IdentExpr(const IdentExpr &);
  IdentExpr &operator=(const IdentExpr &);
  IdentExpr(Ident p1);
  llvm::Value* genCode(CodeGeneratorVisitor*);
  ~IdentExpr();
  virtual void accept(Visitor *v);
  virtual IdentExpr *clone() const;
  void swap(IdentExpr &);
};

class LiteralExpr : public Expr
{
public:
  Literal *literal_;

  LiteralExpr(const LiteralExpr &);
  LiteralExpr &operator=(const LiteralExpr &);
  LiteralExpr(Literal *p1);
  llvm::Value* genCode(CodeGeneratorVisitor*);
  ~LiteralExpr();
  virtual void accept(Visitor *v);
  virtual LiteralExpr *clone() const;
  void swap(LiteralExpr &);
};

class LiteralInteger : public Literal
{
public:
  Integer integer_;

  LiteralInteger(const LiteralInteger &);
  LiteralInteger &operator=(const LiteralInteger &);
  LiteralInteger(Integer p1);
  llvm::Value* genCode(CodeGeneratorVisitor*);
  ~LiteralInteger();
  virtual void accept(Visitor *v);
  virtual LiteralInteger *clone() const;
  void swap(LiteralInteger &);
};

class LiteralDouble : public Literal
{
public:
  Double double_;

  LiteralDouble(const LiteralDouble &);
  LiteralDouble &operator=(const LiteralDouble &);
  LiteralDouble(Double p1);
  llvm::Value* genCode(CodeGeneratorVisitor*);
  ~LiteralDouble();
  virtual void accept(Visitor *v);
  virtual LiteralDouble *clone() const;
  void swap(LiteralDouble &);
};

class LiteralString : public Literal
{
public:
  String string_;

  LiteralString(const LiteralString &);
  LiteralString &operator=(const LiteralString &);
  LiteralString(String p1);
  llvm::Value* genCode(CodeGeneratorVisitor*);
  ~LiteralString();
  virtual void accept(Visitor *v);
  virtual LiteralString *clone() const;
  void swap(LiteralString &);
};

class LiteralBoolean : public Literal
{
public:
  Boolean boolean_;

  LiteralBoolean(const LiteralBoolean &);
  LiteralBoolean &operator=(const LiteralBoolean &);
  LiteralBoolean(Boolean p1);
  llvm::Value* genCode(CodeGeneratorVisitor*);
  ~LiteralBoolean();
  virtual void accept(Visitor *v);
  virtual LiteralBoolean *clone() const;
  void swap(LiteralBoolean &);
};



class ListFunDef : public Visitable, public std::vector<FunDef*>
{
public:
  virtual void accept(Visitor *v);
  llvm::Value* genCode(CodeGeneratorVisitor* v);
  virtual ListFunDef *clone() const;
};

class ListArg : public Visitable, public std::vector<Arg*>
{
public:
  virtual void accept(Visitor *v);
  llvm::Value* genCode(CodeGeneratorVisitor* v);
  virtual ListArg *clone() const;
};

class ListInstr : public Visitable, public std::vector<Instr*>
{
public:
  virtual void accept(Visitor *v);
  llvm::Value* genCode(CodeGeneratorVisitor* v);
  virtual ListInstr *clone() const;
};

class ListDecl : public Visitable, public std::vector<Decl*>
{
public:
  virtual void accept(Visitor *v);
  llvm::Value* genCodeWithType(const llvm::Type *, CodeGeneratorVisitor* v);
  llvm::Value* genCode(CodeGeneratorVisitor* v);
  virtual ListDecl *clone() const;
};

class ListExpr : public Visitable, public std::vector<Expr*>
{
public:
  virtual void accept(Visitor *v);
  llvm::Value* genCode(CodeGeneratorVisitor* v);
  llvm::Value* genCode(CodeGeneratorVisitor*, llvm::Function*);
  virtual ListExpr *clone() const;
};



#endif
